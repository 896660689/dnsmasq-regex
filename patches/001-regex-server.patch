diff --git a/Makefile b/Makefile
index 2549e7c..d54f92b 100644
--- a/Makefile
+++ b/Makefile
@@ -69,6 +69,8 @@ nettle_libs =   `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_DNSSEC     $(PKG_CO
                                                         HAVE_CRYPTOHASH $(PKG_CONFIG) --libs nettle \
                                                         HAVE_NETTLEHASH $(PKG_CONFIG) --libs nettle`
 gmp_libs =      `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_DNSSEC NO_GMP --copy -lgmp`
+regex_cflags =  `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_REGEX $(PKG_CONFIG) --cflags libpcre`
+regex_libs =    `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_REGEX $(PKG_CONFIG) --libs libpcre`
 sunos_libs =    `if uname | grep SunOS >/dev/null 2>&1; then echo -lsocket -lnsl -lposix4; fi`
 version =     -DVERSION='\"`$(top)/bld/get-version $(top)`\"'
 
@@ -90,8 +92,8 @@ hdrs = dnsmasq.h config.h dhcp-protocol.h dhcp6-protocol.h \
 all : $(BUILDDIR)
 	@cd $(BUILDDIR) && $(MAKE) \
  top="$(top)" \
- build_cflags="$(version) $(dbus_cflags) $(idn2_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags) $(nettle_cflags)" \
- build_libs="$(dbus_libs) $(idn2_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(nettle_libs) $(gmp_libs) $(ubus_libs)" \
+ build_cflags="$(version) $(dbus_cflags) $(idn2_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags) $(nettle_cflags) $(regex_cflags)" \
+ build_libs="$(dbus_libs) $(idn2_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(nettle_libs) $(gmp_libs) $(ubus_libs) $(regex_libs)" \
  -f $(top)/Makefile dnsmasq 
 
 mostly_clean :
@@ -115,8 +117,8 @@ all-i18n : $(BUILDDIR)
 	@cd $(BUILDDIR) && $(MAKE) \
  top="$(top)" \
  i18n=-DLOCALEDIR=\'\"$(LOCALEDIR)\"\' \
- build_cflags="$(version) $(dbus_cflags) $(idn2_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags) $(nettle_cflags)" \
- build_libs="$(dbus_libs) $(idn2_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(nettle_libs) $(gmp_libs) $(ubus_libs)"  \
+ build_cflags="$(version) $(dbus_cflags) $(idn2_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags) $(nettle_cflags) $(regex_cflags)" \
+ build_libs="$(dbus_libs) $(idn2_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(nettle_libs) $(gmp_libs) $(ubus_libs) $(regex_libs)"  \
  -f $(top)/Makefile dnsmasq
 	for f in `cd $(PO); echo *.po`; do \
 		cd $(top) && cd $(BUILDDIR) && $(MAKE) top="$(top)" -f $(top)/Makefile $${f%.po}.mo; \
diff --git a/src/config.h b/src/config.h
index 30e23d8..c82a675 100644
--- a/src/config.h
+++ b/src/config.h
@@ -192,6 +192,7 @@ RESOLVFILE
 /* #define HAVE_CONNTRACK */
 /* #define HAVE_CRYPTOHASH */
 /* #define HAVE_DNSSEC */
+/* #define HAVE_REGEX */
 
 
 /* Default locations for important system files. */
@@ -382,6 +383,10 @@ static char *compile_opts =
 "no-"
 #endif
 "i18n "
+#ifndef HAVE_REGEX
+"no-"
+#endif
+"regex "
 #if defined(HAVE_LIBIDN2)
 "IDN2 "
 #else
diff --git a/src/dnsmasq.h b/src/dnsmasq.h
index b21fc17..ae99c72 100644
--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -153,6 +153,10 @@ extern int capget(cap_user_header_t header, cap_user_data_t data);
 #include <priv.h>
 #endif
 
+#ifdef HAVE_REGEX
+#include <pcre.h>
+#endif
+
 /* Backwards compat with 2.83 */
 #if defined(HAVE_NETTLEHASH)
 #  define HAVE_CRYPTOHASH
@@ -567,6 +571,10 @@ struct randfd_list {
 struct server {
   u16 flags, domain_len;
   char *domain;
+#ifdef HAVE_REGEX
+  pcre *regex;
+  pcre_extra *pextra;
+#endif
   struct server *next;
   int serial, arrayposn;
   int last_server;
@@ -588,6 +596,10 @@ struct server {
 struct serv_addr4 {
   u16 flags, domain_len;
   char *domain;
+#ifdef HAVE_REGEX
+  pcre *regex;
+  pcre_extra *pextra;
+#endif
   struct server *next;
   struct in_addr addr;
 };
@@ -595,6 +607,10 @@ struct serv_addr4 {
 struct serv_addr6 {
   u16 flags, domain_len;
   char *domain;
+#ifdef HAVE_REGEX
+  pcre *regex;
+  pcre_extra *pextra;
+#endif
   struct server *next;
   struct in6_addr addr;
 };
@@ -602,6 +618,10 @@ struct serv_addr6 {
 struct serv_local {
   u16 flags, domain_len;
   char *domain;
+#ifdef HAVE_REGEX
+  pcre *regex;
+  pcre_extra *pextra;
+#endif
   struct server *next;
 };
 
@@ -1091,6 +1111,9 @@ extern struct daemon {
   struct iname *if_names, *if_addrs, *if_except, *dhcp_except, *auth_peers, *tftp_interfaces;
   struct bogus_addr *bogus_addr, *ignore_addr;
   struct server *servers, *local_domains, **serverarray, *no_rebind;
+#ifdef HAVE_REGEX
+  int regexserverarraysz, regexlocaldomainarraysz;
+#endif
   int serverarraysz;
   struct ipsets *ipsets;
   u32 allowlist_mask;
@@ -1744,6 +1767,11 @@ void dump_packet(int mask, void *packet, size_t len, union mysockaddr *src, unio
 #endif
 
 /* domain-match.c */
+#ifdef HAVE_REGEX
+int is_local_regex_answer(const char *domain, int *first, int *last);
+int find_regex_server(const char* domain, int is_local, int *arraypos);
+int match_regex(const pcre *regex, const pcre_extra *pextra, const char *str, size_t len);
+#endif
 void build_server_array(void);
 int lookup_domain(char *qdomain, int flags, int *lowout, int *highout);
 int filter_servers(int seed, int flags, int *lowout, int *highout);
diff --git a/src/domain-match.c b/src/domain-match.c
index acaafbf..7ac0663 100644
--- a/src/domain-match.c
+++ b/src/domain-match.c
@@ -24,18 +24,44 @@ void build_server_array(void)
 {
   struct server *serv;
   int count = 0;
-  
-  for (serv = daemon->servers; serv; serv = serv->next)
+#ifdef HAVE_REGEX
+  int regexserverarrayidx = 0;
+  int regexlocaldomainarrayidx = 0;
+  int totalcount = 0;
+  daemon->regexserverarraysz = 0;
+  daemon->regexlocaldomainarraysz = 0;
+#endif
+
+  for (serv = daemon->servers; serv; serv = serv->next){
+#ifdef HAVE_REGEX
+    if(serv->regex)
+      ++daemon->regexserverarraysz;
+    else
+#endif
     count++;
+  }
 
-  for (serv = daemon->local_domains; serv; serv = serv->next)
+  for (serv = daemon->local_domains; serv; serv = serv->next){
+#ifdef HAVE_REGEX
+    if(serv->regex)
+      ++daemon->regexlocaldomainarraysz;
+    else
+#endif
     count++;
-  
+  }
+
+#ifdef HAVE_REGEX
+  totalcount = count + daemon->regexserverarraysz + daemon->regexlocaldomainarraysz;
+  if (totalcount > daemon->serverarraysz)
+    {
+      struct server **new;
+      if ((new = whine_malloc(totalcount * sizeof(struct server *))))
+#else
   if (count > daemon->serverarraysz)
     {
       struct server **new;
-
       if ((new = whine_malloc(count * sizeof(struct server *))))
+#endif
 	{
 	  if (daemon->serverarray)
 	    free(daemon->serverarray);
@@ -46,22 +72,47 @@ void build_server_array(void)
     }
 
   count = 0;
+#ifdef HAVE_REGEX
+    regexserverarrayidx = daemon->serverarraysz;
+    regexlocaldomainarrayidx = regexserverarrayidx + daemon->regexserverarraysz;
+#endif
   
-  for (serv = daemon->servers; serv; serv = serv->next, count++)
+  for (serv = daemon->servers; serv; serv = serv->next)
     {
+#ifdef HAVE_REGEX
+      if(serv->regex){
+        daemon->serverarray[regexserverarrayidx++]=serv;
+        continue;
+      }
+#endif
       daemon->serverarray[count] = serv;
       serv->serial = count;
       serv->last_server = -1;
+
+      ++count;
     }
 
-  for (serv = daemon->local_domains; serv; serv = serv->next, count++)
+  for (serv = daemon->local_domains; serv; serv = serv->next){
+#ifdef HAVE_REGEX
+      if(serv->regex){
+        daemon->serverarray[regexlocaldomainarrayidx++]=serv;
+        continue;
+      }
+#endif
     daemon->serverarray[count] = serv;
+
+    ++count;
+  }
   
   qsort(daemon->serverarray, daemon->serverarraysz, sizeof(struct server *), order_qsort);
 
   /* servers need the location in the array to find all the whole
      set of equivalent servers from a pointer to a single one. */
+#ifdef HAVE_REGEX
+  for (count = 0; count < daemon->serverarraysz + daemon->regexserverarraysz; count++)
+#else
   for (count = 0; count < daemon->serverarraysz; count++)
+#endif
     if (!(daemon->serverarray[count]->flags & (SERV_LITERAL_ADDRESS | SERV_USE_RESOLV)))
       daemon->serverarray[count]->arrayposn = count;
 }
@@ -86,10 +137,15 @@ int lookup_domain(char *qdomain, int flags, int *lowout, int *highout)
   int try, high, low = 0;
   int nlow = 0, nhigh = 0;
   char *cp;
+  int founddomain = 0;
+#ifdef HAVE_REGEX
+  char* originaldomain = qdomain;
+  int needsearchregex = 1;
+#endif
 
   /* may be no configured servers. */
   if (daemon->serverarraysz == 0)
-    return 0;
+    goto search_regex;
   
   /* find query length and presence of '.' */
   for (cp = qdomain, nodots = 1, qlen = 0; *cp; qlen++, cp++)
@@ -211,9 +267,27 @@ int lookup_domain(char *qdomain, int flags, int *lowout, int *highout)
     *highout = nhigh;
 
   if (nlow == nhigh)
-    return 0;
+    goto search_regex;
+
+  founddomain = 1;
+
+search_regex:
+#ifdef HAVE_REGEX
+  if (founddomain){
+    if (daemon->serverarray[nlow]->domain_len > 0) // have found a valid upstream
+      needsearchregex = 0;
+  }
 
-  return 1;
+  if (needsearchregex && find_regex_server(originaldomain, 0, &low)){
+    if (lowout)
+      *lowout = low;
+    if (highout)
+      *highout = low + 1;
+
+    founddomain = 1;
+  }
+#endif
+  return founddomain;
 }
 
 /* Return first server in group of equivalent servers; this is the "master" record. */
@@ -299,6 +373,68 @@ int filter_servers(int seed, int flags, int *lowout, int *highout)
   return (nlow != nhigh);
 }
 
+#ifdef HAVE_REGEX
+// return flags, or 0 if not found
+int is_local_regex_answer(const char *domain, int *first, int *last)
+{
+  int flags = 0;
+  int rc = 0;
+  int arraypos = 0;
+  if(find_regex_server(domain, 1, &arraypos)){
+    struct server *r = daemon->serverarray[arraypos];
+    *first = arraypos;
+    *last = *first + 1;
+
+    flags = r->flags;
+    if (flags & SERV_4ADDR)
+      rc = F_IPV4;
+    else if (flags & SERV_6ADDR)
+      rc = F_IPV6;
+    else if (flags & SERV_ALL_ZEROS)
+      rc = F_IPV4 | F_IPV6;
+  }
+  return rc;
+}
+
+// return 0 if failed to find
+int find_regex_server(const char* domain, int is_local, int *arraypos)
+{
+  int iFirst = daemon->serverarraysz;
+  int iLast = daemon->serverarraysz + daemon->regexserverarraysz - 1;
+  const size_t domainLength = strlen(domain);
+
+  if (is_local){
+    iFirst = iLast + 1;
+    iLast += daemon->regexlocaldomainarraysz;
+  }
+
+  while(iFirst <= iLast){
+    struct server* r = daemon->serverarray[iLast];
+    if (match_regex(r->regex, r->pextra, domain, domainLength)){
+      *arraypos=iLast;
+      return 1;
+    }
+    --iLast;
+  }
+
+  return 0;
+}
+
+// return 0 if failed to match
+int match_regex(const pcre *regex, const pcre_extra *pextra, const char *str, size_t len)
+{
+	int captcount = 0;
+	int ret = 0;
+	if (pcre_fullinfo(regex, pextra, PCRE_INFO_CAPTURECOUNT, &captcount) == 0)
+	{
+		/* C99 dyn-array, or alloca must be used */
+		int ovect[(captcount + 1) * 3];
+		ret = pcre_exec(regex, pextra, str, len, 0, 0, ovect, (captcount + 1) * 3) > 0;
+	}
+	return ret;
+}
+#endif
+
 int is_local_answer(time_t now, int first, char *name)
 {
   int flags = 0;
diff --git a/src/forward.c b/src/forward.c
index 9b8b8db..e77ed5c 100644
--- a/src/forward.c
+++ b/src/forward.c
@@ -275,6 +275,11 @@ static int forward_query(int udpfd, union mysockaddr *udpaddr,
       /* Configured answer. */
       if ((flags = is_local_answer(now, first, daemon->namebuff)))
 	goto reply;
+
+#ifdef HAVE_REGEX
+	if ((flags = is_local_regex_answer(daemon->namebuff, &first, &last)))
+		goto reply;
+#endif
       
       master = daemon->serverarray[first];
       
@@ -357,10 +362,15 @@ static int forward_query(int udpfd, union mysockaddr *udpaddr,
 	{
 	  /* retry on existing query, from original source. Send to all available servers  */
 	  forward->sentto->failed_queries++;
-	  
+#ifdef HAVE_REGEX
+		if(forward->sentto->regex){
+			start = first = forward->sentto->arrayposn;
+			last = first + 1;
+			forward->forwardall = 0;
+		}else
 	  if (!filter_servers(forward->sentto->arrayposn, F_SERVER, &first, &last))
 	    goto reply;
-	  
+#endif
 	  master = daemon->serverarray[first];
 	  
 	  /* Forward to all available servers on retry of query from same host. */
@@ -446,8 +456,13 @@ static int forward_query(int udpfd, union mysockaddr *udpaddr,
   while (1)
     { 
       int fd;
-      struct server *srv = daemon->serverarray[start];
-      
+
+	struct server *srv = daemon->serverarray[start];
+#ifdef HAVE_REGEX
+	if (srv->regex)
+		forward->forwardall = 0; // make it send only once
+#endif
+
       if ((fd = allocate_rfd(&forward->rfds, srv)) != -1)
 	{
 	  
@@ -1826,6 +1841,9 @@ unsigned char *tcp_request(int confd, time_t now,
   int have_mark = 0;
   int first, last;
   unsigned int flags = 0;
+#ifdef HAVE_REGEX
+  int foundServer = 0;
+#endif
   
   if (getpeername(confd, (struct sockaddr *)&peer_addr, &peer_len) == -1)
     return packet;
@@ -1998,10 +2016,23 @@ unsigned char *tcp_request(int confd, time_t now,
 		  !strchr(daemon->namebuff, '.') &&
 		  strlen(daemon->namebuff) != 0)
 		flags = F_NOERR;
+#ifdef HAVE_REGEX
+		else{
+			foundServer = lookup_domain(daemon->namebuff, gotname, &first, &last);
+			flags = is_local_answer(now, first, daemon->namebuff);
+			if(!flags)
+				flags = is_local_regex_answer(daemon->namebuff, &first, &last);
+			if(foundServer && !flags)
+#else
 	      else if (lookup_domain(daemon->namebuff, gotname, &first, &last) && !(flags = is_local_answer(now, first, daemon->namebuff)))
+#endif
 		{
 		  master = daemon->serverarray[first];
-		  
+#ifdef HAVE_REGEX
+			if(master->regex)
+				start = first;
+			else
+#endif
 		  if (option_bool(OPT_ORDER) || master->last_server == -1)
 		    start = first;
 		  else
@@ -2082,9 +2113,12 @@ unsigned char *tcp_request(int confd, time_t now,
 				    option_bool(OPT_NO_REBIND) && !norebind, no_cache_dnssec, cache_secure, bogusanswer,
 				    ad_reqd, do_bit, added_pheader, check_subnet, &peer_addr); 
 		}
+#ifdef HAVE_REGEX
+		}
+#endif
 	    }
 	}
-      
+
       /* In case of local answer or no connections made. */
       if (m == 0)
 	{
diff --git a/src/network.c b/src/network.c
index 52291b4..c4a938c 100644
--- a/src/network.c
+++ b/src/network.c
@@ -1735,6 +1735,10 @@ void check_servers(void)
 	    s1 = _("unqualified"), s2 = _("names");
 	  else if (strlen(serv->domain) == 0)
 	    s1 = _("default"), s2 = "";
+#ifdef HAVE_REGEX
+    else if (serv->regex)
+      s1 = _("regex domain"), s2 = serv->domain;
+#endif
 	  else
 	    s1 = _("domain"), s2 = serv->domain;
 	  
diff --git a/src/option.c b/src/option.c
index 843ec24..babf7d7 100644
--- a/src/option.c
+++ b/src/option.c
@@ -748,6 +748,19 @@ static void add_txt(char *name, char *txt, int stat)
 }
 #endif
 
+#ifdef HAVE_REGEX
+static const char *parse_regex_option(const char *arg, pcre **regex, pcre_extra **pextra)
+{
+  const char *error;
+  int erroff;
+  *regex = pcre_compile(arg, 0, &error, &erroff, NULL);
+  if(NULL == *regex)
+    return error;
+  *pextra = pcre_study(*regex, 0, &error);
+  return NULL;
+}
+#endif
+
 static void do_usage(void)
 {
   char buff[100];
@@ -2641,6 +2654,10 @@ static int one_opt(int option, char *arg, char *errstr, char *gen_err, int comma
       {
 	struct server *new;
 	size_t size;
+#ifdef HAVE_REGEX
+	char* regex = NULL;
+	char* regex_end = NULL;
+#endif
 	char *lastdomain = NULL, *domain = "";
 	char *alloc_domain;
 	u16 flags = 0;
@@ -2666,6 +2683,14 @@ static int one_opt(int option, char *arg, char *errstr, char *gen_err, int comma
 		lastdomain = arg;
 		arg = last;
 	      }
+#ifdef HAVE_REGEX
+		regex_end = domain + strlen(domain);
+		if (*domain == ':' && *(regex_end - 1) == ':'){
+			++domain; // skip leading ':'
+			*(regex_end - 1) = '\0'; // skip tailing ':'
+			regex = domain;
+		}
+#endif
 	  }
 	
 	if (servers_only && option == 'S')
@@ -2748,10 +2773,21 @@ static int one_opt(int option, char *arg, char *errstr, char *gen_err, int comma
 	if (strlen(domain) == 0 && lastdomain)
 	  flags |= SERV_FOR_NODOTS;
 	
+#ifdef HAVE_REGEX
+	if (regex){
+		if ((err = (char *)parse_regex_option(regex, &new->regex, &new->pextra)))
+			ret_err(err);
+	}
+#endif
+
 	new->flags = flags;
 
 	/* If we have more than one domain, copy and iterate */
+#ifdef HAVE_REGEX
+	if (lastdomain && NULL == regex)
+#else
 	if (lastdomain)
+#endif
 	   while (domain != lastdomain)
 	     {
 	       struct server *last = new;
